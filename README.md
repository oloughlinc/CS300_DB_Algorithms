# CS300_Project: Data Structures

# What was the problem you were solving in the projects for this course?

In the project we explored the advantages and disadvantages of different data structures in the context of a problem: holding a list of college courses with their prerequisites in computer memory, accessing them by search or in order if needed. In the first part, we examined the runtime and developed pseudocode for three different data structures, and in part two, built a functional console program using a selected data structure to solve this problem.

# How did you approach the problem? Consider why data structures are important to understand.

Every computer program stores some kind of data. Being able to store and manipulate data, especially large sets, is one of the advantages of computer science. Each data structure available to the system designer can offer unique advantages depending on the problem. For this problem, considering a runtime analysis of different structures vs. what the requirements of the problem were led to the final implementation. Based on the analysis, I chose a binary search tree; although there are other valid choices (possibly even more suitable) for this problem as well.

# How did you overcome any roadblocks you encountered while going through the activities or project?

The two main challenges in the project were developing a runtime analysis for each function designed in pseudocode, and building a scratch implementation of our chosen structure in the final project. As I continue to learn I have relied extensively on documentation of standard library functions and on common knowledge bases such as stackoverflow. 

# How has your work on this project expanded your approach to designing software and developing programs?

One of the main things learned in the project is to plan an approach before committing to development. Doing so can yield surprising insights. At the very least, planning a system out based on the problem to be solved affords us time to think about the problem in context, before getting lost in a coding solution that in hindsight was not the clearest path forward.

# How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

Clean programming practices are something that require another level of thought on top of the problem solution. Code that can be easily worked on is code that is simple in purpose and broken into components that each focus on a single problem to solve. For example, this solution is broken into multiple classes that each work in their own scope. Components built here are transferable if needed to different projects, since it was built with object oriented principles and interactions between components are well ordered. 
